*vim9class.txt*	For Vim バージョン 9.0.  Last change: 2023 Feb 26


		  VIMリファレンスマニュアル    by Bram Moolenaar


NOTE - これはまだ完了しておらず、なんであれ変更することがあります! - NOTE


Vim9 のクラス、オブジェクト、インターフェイス、型と列挙値。

1.  概要			|Vim9-class-overview|
2.  単純なクラス		|Vim9-simple-class|
3.  クラスのメンバと関数	|Vim9-class-member|
4.  抽象クラスを使う		|Vim9-abstract-class|
5.  インターフェイスを使う	|Vim9-using-interface|
6.  さらなるクラスの詳細	|Vim9-class|
7.  型の定義			|Vim9-type|
8.  列挙値			|Vim9-enum|

9.  論理的根拠
10. 後で書く

==============================================================================

1. 概要						*Vim9-class-overview*

「オブジェクト指向プログラミング」は夢の単語です。この題材について、あなたは多
数の勉強素材を見付けることができます。ここではあなたがすでに基本的なことを知っ
ていると仮定して、|Vim9| script が何を提供するかを記載します。加えて、この機能
を効率的に利用する方法についての有用なヒントも記載します。

オブジェクトの基本用語:
- オブジェクトは状態を持つ。1つあるいはそれ以上のそれぞれ値を持つ変数を包含し
  ている。
- オブジェクトはその状態の使用と操作を行う関数を提供する。それらの関数は「その
  オブジェクト上で」呼び出される。これが従来のデータとそのデータを操作するコー
  ドの分離とは一線を画すものになっている。
- オブジェクトには型指定されたメンバ変数とメンバ関数によって、明確に定義された
  インターフェイスがある。
- オブジェクトはクラスから作られ、すべてのオブジェクトは同じインターフェイスを
  持つ。 これは実行時には変更できず、動的ではない。

オブジェクトはクラスによってのみ生成されます。クラスは以下を提供します:
- コンストラクタとしての new() メソッド、これはクラスからオブジェクトを返しま
  す。このメソッドはクラス名で呼び出す: MyClass.new()。
- クラスにおける全オブジェクトで状態を共有する: クラス変数(クラスメンバ)。
- 親クラスを子クラスが継承することでクラスの階層になる。

インターフェイスはオブジェクトのプロパティを指定するのに使用されます:
- オブジェクトはいくつかのインターフェイスを実装する宣言ができる。
- 同じインターフェイスを実装した異なるオブジェクトを同じように扱うことができ
  る。

クラス階層は単一の継承になります。その単一のもの以外が必要な場面ではインター
フェイスを使ってください。


クラスのモデリング ~

あたなの好きなようにクラスをモデル化できます。何を構築するのかを忘れずに、現実
をモデル化しようとしないでください。これは混乱を招く可能性があります、特に講師
は現実世界のオブジェクトを使ってクラスの関係を説明するので、モデルが現実を反映
する必要があると考えてしまうのです。そうではありません! モデルはあなたの目的に
合わせるべきです。

合成(オブジェクトが他のオブジェクトを含む)は多くの場合で継承(別のオブジェクト
を拡張したオブジェクト)より優れていることに留意してください。最適なクラスのモ
デルを見付けようとして時間を無駄にしないように。あるいは正方形が長方形なのか長
方形が正方形なのかで議論するのは時間の無駄です。それは問題ではありません。


==============================================================================

2.  単純なクラス				*Vim9-simple-class*

まずは簡単な例で始めてみましょう: テキストの位置を格納するクラスです(どのよう
により効率的にしているかは以下を参照): >

	class TextPosition
	   this.lnum: number
	   this.col: number

	   def new(lnum: number, col: number)
	      this.lnum = lnum
	      this.col = col
	   enddef

	   def SetLnum(lnum: number)
	      this.lnum = lnum
	   enddef

	   def SetCol(col: number)
	      this.col = col
	   enddef

	   def SetPosition(lnum: number, col: number)
	      this.lnum = lnum
	      this.col = col
	   enddef
	 endclass
<							*object* *Object*
このクラスと new() メソッドからオブジェクトを生成できます: >

	var pos = TextPosition.new(1, 1)

このオブジェクトのメンバ "lnum" と "col" は直接アクセスできます: >

	echo $'The text position is ({pos.lnum}, {pos.col})'
<							*E1317* *E1327*
他のオブジェクト指向言語を使ったことがあるなら Vim のオブジェクトのメンバは一
貫してプリフィックス "this." で参照されていることに気付くでしょう。これは Java
や TypeScript のような他の言語とは違います。この命名規約はオブジェクトのメンバ
を容易に見付ることができます。また、プリフィックス "this." がない変数の時はオ
ブジェクトのメンバでないとわかります。


メンバの書き込みアクセス ~

オブジェクトのメンバの直接変更を試してください: >

	pos.lnum = 9
<							*E1335*
これはエラーになります! デフォルトではオブジェクトのメンバは読むことはできます
が設定できないためです。そのため TextPosition クラスはそのためのメソッドを提供
しています: >

	pos.SetLnum(9)

オブジェクトのメンバが読めるけれども設定できないようにするのがもっとも一般的で
最良の安全な手段となっています。ほとんどの場合で値を使用しても問題はありません
が、値を設定するのは注意が必要な副作用が生じることがあります。この場合では、
SetLnum() メソッドは行番号が有効かチェックでき、同時にエラーを発生させるかもっ
とも近い有効な値を使うかができます。
							*:public* *E1331*
副作用について考慮する必要がなくオブジェクトのメンバが何時でも変更を受け付ける
ようにしたいなら、パブリックにすることができます: >

	public this.lnum: number
	public this.col: number

このとき、SetLnum(), SetCol(), SetPosition() メソッドは必要なく、"pos.lnum" に
直接設定してもエラーになることはありません。
							*E1334*
オブジェクトのメンバとして存在しないものに設定する場合はエラーになります: >
	pos.other = 9
<	E1334: Object member not found: other ~


プライベートメンバ ~
							*E1332* *E1333*
一方で、オブジェクトのメンバを直接読めないようにしたい場合、それらをプライベー
トにできます。名前にアンダースコアを前置すればそうなります: >

	this._lnum: number
	this._col number

その時はプライベートなメンバの値を取得するメソッドを提供する必要があります。一
般的にゲッターと呼ばれるものです。使用する名前は "Get" で始めることを推奨しま
す: >

	def GetLnum(): number
	   return this._lnum
	enddef

	def GetCol() number
	   return this._col
	enddef

この例はあまり役に立ちません、メンバはパブリックになっているのと同様であるため
です。値をチェックする場合に便利になります。例えば、行番号を全体行数に制限する
のは: >

	def GetLnum(): number
	   if this._lnum > this._lineCount
	      return this._lineCount
	   endif
	   return this._lnum
	enddef


new() メソッドの単純化 ~

多くのコンストラクタはオブジェクトのメンバの値を取ります。なのでこのようなパ
ターンをとてもよく見ます: >

	 class SomeClass
	   this.lnum: number
	   this.col: number

	   def new(lnum: number, col: number)
	      this.lnum = lnum
	      this.col = col
	   enddef
	 endclass

この記述で、1度ではなく各メンバで2度型を書く必要があります。これは非常に一般的
なので new() を短縮する方法が提供されます: >

	   def new(this.lnum, this.col)
	   enddef

この文法はとても理解しやすいです: new() の引数が、"this." を含んだオブジェクト
のメンバ名で提供されており、new() 呼び出し時にオブジェクトのメンバに代入される
ことを意味します。このメカニズムは Dart 言語から来ています。

この new() を使う方法とメンバをパブリックにするのをあわせると当初よりとても短
いクラス定義になります: >

	class TextPosition
	   public this.lnum: number
	   public this.col: number

	   def new(this.lnum, this.col)
	   enddef

	   def SetPosition(lnum: number, col: number)
	      this.lnum = lnum
	      this.col = col
	   enddef
	 endclass

新しいオブジェクトを生成する流れは:
1. メモリを確保しクリアする。すべての値は0/false/空になる。
2. 初期化子で宣言した各メンバについて、式を評価してメンバに代入する。
   これはメンバのクラス内で宣言された順に発生する。
3. new() メソッドの引数のうち、 "this.name" 形式のものの値を代入する。
4. new() メソッドの本体が実行される。

親クラスを拡張したクラスの場合、同様の動作が発生します。2番目のステップでは親
クラスのメンバが先に完了します。親の "super()" や "new()" を呼ぶ必要はありませ
ん。

==============================================================================

3.  クラスのメンバと関数			*Vim9-class-member*

						*:static* *E1337* *E1338*
クラスメンバは "static" とともに宣言します。プリフィックスなしの名前を使いま
す: >

	class OtherThing
	   this.size: number
	   static totalSize: number

	   def new(this.size)
	      totalSize += this.size
	   enddef
	endclass
<							*E1340* *E1341*
名前はそのまま使用されるので、関数の引数名やローカル変数としてシャドウィングす
ることはできません。

オブジェクトのメンバのアクセスと同様に、アンダースコアを名前の最初の文字に使
うことでプライベートにでき、"public" を前置することでパブリックにできます: >

    class OtherThing
	static total: number	      # だれでも読め、クラスだけが書ける
	static _sum: number	      # クラスだけが読み書きできる
	public static result: number  # だれでも読み書きできる
    endclass
<
							*class-function*
クラス関数も同じように "static" とともに宣言します。オブジェクトのメンバへのア
クセスはできず、"this" キーワードは使えません: >

	class OtherThing
	   this.size: number
	   static totalSize: number

	   # 合計サイズをクリアし以前の値を返す。
	   static def ClearTotalSize(): number
	      var prev = totalSize
	      totalSize = 0
	      return prev
	   enddef
	endclass

クラス内では関数は直接名前で呼び出せ、クラス外ではクラス名を前置する必要があり
ます: `OtherThing.ClearTotalSize()`。

==============================================================================

4.  抽象クラスを使う				*Vim9-abstract-class*

抽象クラスは最低でも1つのサブクラスの元となる形式です。クラスのモデルでは、い
くつかのクラスが共有できる同じ属性を持っていることがよくありますが、その属性を
持つクラスではオブジェクトを作るには十分な状態ではありません。オブジェクトを生
成して使う前にサブクラスで抽象クラスを拡張し不足の状態、あるいはメソッドを追加
する必要があります。

例えば、Shape クラスは色と厚みを格納できます。それにはそれが何の形状の種別なの
かという情報が欠けているので、Shape のオブジェクトは生成できません。Shape クラ
スの機能は Square と Triangle クラスの基礎となり、オブジェクトが生成できます。
例: >

	abstract class Shape
	   this.color = Color.Black
	   this.thickness = 10
	endclass

	class Square extends Shape
	   this.size: number

	   def new(this.size)
	   enddef
	endclass

	class Triangle extends Shape
	   this.base: number
	   this.height: number

	   def new(this.base, this.height)
	   enddef
	endclass
<
抽象クラスは new() メソッドが無いことを除けば、通常のクラスと同じ方法で定義で
きます。 *E1359*


==============================================================================

5.  インターフェイスを使う			*Vim9-using-interface*

上記の例で、Shape, Square, Triangle にオブジェクトの面積の計算メソッドが追加で
きた場合、より便利になります。HasSurface いうインターフェイスを作成し、これには
数値を返す Surface() という1つのメソッドを記述します。この例で上のものを拡張す
ると: >

	abstract class Shape
	   this.color = Color.Black
	   this.thickness = 10
	endclass

	interface HasSurface
	   def Surface(): number
	endinterface

	class Square extends Shape implements HasSurface
	   this.size: number

	   def new(this.size)
	   enddef

	   def Surface(): number
	      return this.size * this.size
	   enddef
	endclass

	class Triangle extends Shape implements HasSurface
	   this.base: number
	   this.height: number

	   def new(this.base, this.height)
	   enddef

	   def Surface(): number
	      return this.base * this.height / 2
	   enddef
	endclass

クラスでインターフェイスを実装すると宣言した場合、インターフェイスに記述されて
いるすべての項目が同じ型でクラスに存在する必要があります。 *E1348* *E1349*

インターフェイスの名前は型と同じように使えます: >

	var shapes: list<HasSurface> = [
				Square.new(12),
				Triangle.new(8, 15),
				]
	for shape in shapes
	   echo $'the surface is {shape.Surface()}'
	endfor


==============================================================================

6.  さらなるクラスの詳細			*Vim9-class* *Class* *class*

クラスの定義 ~
					*:class* *:endclass* *:abstract*
クラスは`:class` から `:endclass` の間に定義されます。クラス全体が 1 つのスクリ
プトファイルに定義されます。クラスに後から追加することはできません。

|Vim9| script ファイルの中にのみクラスは定義できます。  *E1316*
クラスは関数内には定義できません。

スクリプトファイルに1つ以上のクラスを定義できます。ただ通常はメインとなるクラ
スだけをエクスポートすることをお勧めします。ただし、型、列挙型、ヘルパークラス
を定義すると便利な場合があります。

`:abstract` キーワードを前置したり `:export` が使えたりします。以下のようなバ
リエーションになります: >

	class ClassName
	endclass

	export class ClassName
	endclass

	abstract class ClassName
	endclass

	export abstract class ClassName
	endclass
<
							*E1314*
クラス名はキャメルケース(CamelCased)でなくてはいけません。開始は大文字の必要が
あります。これは組み込みの型との衝突を回避します。
							*E1315*
クラス名の後にはオプショナルな項目を使うことができます。それぞれ1度だけ表記で
きます。好きな順序で表記できますが、この順序を推奨します: >
	extends ClassName
	implements InterfaceName, OtherInterface
	specifies SomeInterface
<							*E1355*
各メンバと関数名は一度だけ使えます。関数を同じ名前で違う引数の型では定義するこ
とはできません。


クラスの拡張 ~
							*extends*
クラスは他のクラスを拡張できます。 *E1352* *E1353* *E1354*
基本的なアイデアは頂点に既存のクラスを置いて、プロパティを追加して作っていくと
いうものです。

拡張されたクラスは "基底クラス" あるいは "親クラス" と呼ばれます。新しいクラス
は "子クラス" と呼ばれます。

基底クラスのオブジェクトのメンバはすべて子クラスに持ち越されます。これはそれら
が上書きできないことを意味します(いくつかの他の言語とは違います)。

						*E1356* *E1357* *E1358*
基底クラスのオブジェクトメソッドは封印することができます。シグニチャ (引数、引
数の型、戻り値の型) が完全に一致している必要があります。基底クラスのメソッドは
"super." を前置することで呼び出すことができます。

他の基底クラスのオブジェクトメソッドは子クラスに持ち越されます。

"new" で始まる関数を含むクラス関数は、オブジェクトのメソッド同様に破棄されま
す。基底クラスにある関数は(クラス関数であれば)クラス名、あるいは "super." を前
置して呼べます。

他の言語とは違い、基底クラスのコンストラクタの実行は必要ではありません。実際、
実行できません。子クラスでも基底クラスのいくつかの初期化を実行する必要があるな
ら、オブジェクトのメソッドとして用意し、そのメソッドを各コンストラクタで呼びま
す。

基底クラスに new() 関数がない場合にはひとつ自動生成されます。その関数は子クラ
スには持ち越さることはありません。子クラスでは自分で new() 関数を定義でき、あ
るいはひとつも定義しないなら自動で追加されます。


インターフェイスを実装したクラス ~
						*implements* *E1346* *E1347*
クラスは1つ以上のインターフェイスを実装できます。"implements" キーワードは1度
だけ表記できます *E1350* 。複数のインターフェイスをコンマ区切りで指定できます。
各インターフェイスは1度だけ表記できます。 *E1351*


インターフェイスを定義するクラス ~
							*specifies*
クラスは名前付きインターフェイスを使用して、そのオブジェクトのメンバとメソッド
のインターフェイスを宣言できます。これは多くの言語、特にJavaでよく行なわている
個別のインターフェイスを分離して明記する必要を回避できます。


クラスの項目 ~
						*E1318* *E1325* *E1326*
`:class` と `:endclass` の間のクラス内で、以下の項目を表記できます:
- オブジェクトのメンバの宣言: >
	this._memberName: memberType
	this.memberName: memberType
	public this.memberName: memberType
- コンストラクタメソッド: >
	def new(arguments)
	def newName(arguments)
- オブジェクトメソッド: >
	def SomeMethod(arguments)
<							*E1329*
オブジェクトのメンバの型は指定しなくてはいけません。最良の実施方法は ": {type}"
を使って明示することです。単純な型であれば、"= 123" のような初期化子を使うこと
もでき、Vimはその型を数値であるとみなします。複雑な型を不完全な状態にするのは
避けましょう。例えば: >
	this.nameList = []
これはリストであると指定していますが、項目の型が不明です。より良くするには: >
	this.nameList: list<string>
初期化は必要なく、リストはデフォルトで空になります。
							*E1330*
"void", "null", "v:none" といったいくつかの型は使えません。


インターフェイスの定義 ~
						*:interface* *:endinterface*
インターフェイスは `:interface` から `:endinterface` の間に定義されます。
`:export` を前置できます: >

	interface InterfaceName
	endinterface

	export interface InterfaceName
	endinterface
<							*E1344*
インターフェイスにはオブジェクトのメンバを、初期化子無しでクラスと同じように宣
言できます。
							*E1345*
インターフェイスには `:def` でメソッドを引数と戻り値の型とともに宣言できます
が、関数の本体と `:enddef` はS宣言できません。例: >

	interface HasSurface
	   this.size: number
	   def Surface(): number
	endinterface

インターフェイスの名前は大文字で始めなくてはいけません。 *E1343*
プリフィックス "Has" は機能が何であるかのヒントとともにインターフェイス名を簡
単に見付られるようにする方法として使うことができます。
インターフェイスは |Vim9| script ファイルでしか宣言できません。 *E1342*


null オブジェクト ~

オブジェクトの型を持つ変数が宣言され、しかし初期化されていない場合は、値は
null になります。null のオブジェクトを使おうとした時に Vim は時々どのクラスを
使用することになっているかわからなくなります。Vim はこの時、メンバ名が正しいか
チェックができず、メンバ名が不正な場合でも "Using a null object" エラーを発生
させます。 *E1360* *E1362*


デフォルトコンストラクタ ~

new() メソッドなしでクラスを定義した場合、ひとつ自動で定義されます。デフォルト
コンストラクタは全オブジェクトメンバを引数に持ち、その順序は定義した順になりま
す。つまりあなたのクラスがこうであれば: >

	class AutoNew
	   this.name: string
	   this.age: number
	   this.gender: Gender
	endclass

デフォルトコンストラクタはこうなります: >

	def new(this.name = v:none, this.age = v:none, this.gender = v:none)
	enddef

引数はデフォルト値 "= v:none" のオプショナルになります。そして `new()` は引数
を任意で省略して呼び出せます。割り当てがされていない場合にはオブジェクトメンバ
のデフォルト値が使われます。この、デフォルト値がとても便利な例として: >

	class TextPosition
	   this.lnum: number = 1
	   this.col: number = 1
	endclass

コンストラクタが引数を持つのを強制したい場合、あなたが書く必要があります。例え
ば、上の AutoNew クラスで名前を取得すると主張するなら、コンストラクタはこのよ
うに定義します: >

	def new(this.name, this.age = v:none, this.gender = v:none)
	enddef
<							*E1328*
Note "v:none" 以外のデフォルト値をここで使うことはできません。オブジェクトメン
バが初期化されるのを望む場合は、宣言するしかありません。この方法はデフォルト値
を1箇所で確認するだけですみます。

全オブジェクトのメンバはデフォルトコンストラクタ、あるいはプライベートなアクセ
スで使用されます。

クラスが拡張された場合、拡張したクラスのオブジェクトのメンバが最初に来ます。


複数のコンストラクタ ~

一般的にはクラスはただ1つの new() コンストラクタを持ちます。コンストラクタが同
じ引数を使用して呼び出されることが多い場合は、それらの引数を 2番目のコンストラ
クタメソッド内に入れることでコードを簡素化できます。例えば、color に黒をよく与
えて使う場合: >

	def new(this.garment, this.color, this.size)
	enddef
	...
	var pants = new(Garment.pants, Color.black, "XL")
	var shirt = new(Garment.shirt, Color.black, "XL")
	var shoes = new(Garment.shoes, Color.black, "45")

コンストラクタに毎回 color を与えて繰り返す代わりに内蔵したものにします: >

	def newBlack(this.garment, this.size)
	   this.color = Color.black
	enddef
	...
	var pants = newBlack(Garment.pants, "XL")
	var shirt = newBlack(Garment.shirt, "XL")
	var shoes = newBlack(Garment.shoes, "9.5")

Note "new" から始まる名前のメソッドにする必要があります。"new()" メソッドがな
い場合は、他のコンストラクタメソッドがあってもデフォルトコンストラクタが追加さ
れます。


==============================================================================

7.  型の定義						*Vim9-type* *:type*

型定義は型の仕様に名前を与えます。 例: >

	:type ListOfStrings list<string>

TODO: さらなる説明


==============================================================================

8.  列挙値					*Vim9-enum* *:enum* *:endenum*

enum は、値のリスト1つを持つことができる型です。 例: >

	:enum Color
		White
		Red
		Green
		Blue
		Black
	:endenum

TODO: さらなる説明


==============================================================================

9. 論理的根拠

|Vim9| クラスの多くの選択は人気があり現在開発されている言語、Java, TypeScript,
Dart などから来ています。構文は、例えばクラス全体を波カッコでくくる代わりに
`endclass` を使用するなど Vim script の動作に合せて作ってあります。

オブジェクト指向言語の一般的な構造の一部は、これらの言語が新しいころの非常に昔
に選択され、後に最適ではないことが判明しました。その時点で、これらの構造は広く
使用されており、それらを変更するのは選択肢ではありませんでした。Vimにおいては
クラスが完全に新規であるため、さまざまな選択をする自由があります。"古い" 言語
が使用するものよりも、構文を単純かつより一貫性のあるものにすることができます。
あまり変更しなければ、既存の言語で知っているものとほとんど同じになるはずです。

いくつかの最近開発されている言語に追加されているファンシーな機能のすべてはVim
では必要ではありません。しかし、中には私たちがぜひ使用したい素晴らしいアイデア
をもっています。そして最終的には人気の言語の共通点を基本とし、問題のあるように
見えるアイデアは落し、いくつかの覚えやすくて素晴しい機能を追加しました。

意思決定として用いる主要なルールは次のとおりです:
- 単純さの維持。
- 驚きはなく、多くの他の言語で使っている。
- 以前からの間違いを防止する。
- スクリプト作成者が、どのように機能するかを理解するためにヘルプを参照する必要
  がなく、ほとんどのことが明白。
- 一貫性を保つ。
- 大規模プロジェクトではなく、標準的なプラグインを標的とする。


コンストラクタとして new() を使用する ~

多くの言語ではクラス名をコンストラクタメソッドとして使用します。欠点は多くの場
合に名前が長いことです。そしてクラス名の変更時にすべてのコンストラクタメソッド
のリネームが必要なことです。大きな事柄ではないですが、それでもデメリットはあり
ます。

他の言語、TypeScriptでは特別な名前として "constructor()" を使用します。これは
より良く見えます。しかしながら、新しいオブジェクトを生成するに "constructor()"
と比べると "new" や "new()" の方が明白です。

|Vim9| script ではすべてのコンストラクタで同じ名前を使用するのが良い選択である
と見做しており、new() で呼び出すことで呼び出し元とメソッドを呼ぶ側の関係が明白
になります。


オーバーロードのないコンストラクタ ~

Vim script の旧来および |Vim9| どちらも、関数のオーバーロードはありません。こ
れが意味するのは、同じ関数名で引数の型が違うものを使うことができないということ
です。したがって new() コンストラクタはただ一つです。

|Vim9| script では引数が型付けされたことで、オーバーロードをサポートすることが
できるようになりました。しかしながら、すぐに煩雑になってしまいます。1度の new()
の呼び出しでは引数の型を調査してどの new() メソッドを呼ぶのが正しいか知る必要
があります。いくつかの new() メソッドは実際に呼び出されます。そのためかなりの
量のコードを検査します。例えば、メソッドが戻り値で引数の1つを返す場合、その型
を返すメソッドを見付ける必要があります。

代わりとして、各コンストラクタが "new" から始まる違う名前を持ちます。この方法
は引数の違う複数のコンストラクタが可能になり、どのコンストラクタを使うべきかと
ても簡単に見分けられます。そして引数の型のチェックもちゃんと行えます。


オーバーロードのないメソッド ~

コンストラクタ(WIP: 題と噛み合ってない?)としている幾つかの理由: ときどき型引数
を持つが明確ではなく、実際にメソッドを呼ぶにはどうすればよいのか説明が困難にな
ります。メソッドには違う名前を与えるのが良く、そして型チェックがあなたの意図す
るように動作します。これにより、実際には必要のないポリモーフィズムが除外されま
す。


単一の継承と複数のインターフェイス ~

いくつかの言語では複数の継承をサポートしています。とはいえそれはいくつかのケー
スで便利になりますが、クラスがどのように動作するかのルールを非常に複雑にしてし
まいます。代わりに、インターフェイスの宣言を使うことでよりシンプルにそれをサ
ポートします。とても人気のあるJava言語ではこの方法にしていて、Vimにもこれで十
分です。ここに "keep it simple" のルールが適用されています。

クラスがサポートするインターフェイスを明示的に宣言することで、クラスの目的が簡
単に見てとれます。また、適した型チェックが行えるようになります。インターフェイ
スが変更されると実装を宣言したクラスもその変更がなされているかがチェックされま
す。メソッドがたまたま一致したからといって、クラスがインターフェイスを実装して
いるとみなすメカニズムは脆弱で、わかりにくい問題を引き起こすため、やめましょ
う。


どこでも "this.member" を使用する ~

多くのプログラミング言語のオブジェクトメンバよく違う方法でアクセスされ、その位
置に依存します。時に "this." を前置することであいまいさを防ぎます。通常、これ
らは "this." なしで宣言されます。これはまったく一貫性がなく時に混乱してしまい
ます。

これはコンストラクタ内で引数と同じ名前がオブジェクトメンバを使うときにとても普
遍的な問題になります。その際にはそれらのメンバはコンストラクタ本体内で "this."
の前置を必要とし、他のメンバには不要で時には除去されています。これは "this."
について有り無しのメンバの混在を引き起し、一貫性がなくなります。

|Vim9| のクラスでは "this." プリフィックスを常に使います。メンバの宣言時でもで
す。シンプルで一貫性があります。クラス内のコードを見た時に変数がオブジェクトメ
ンバかそうでないものを指しているかが直接的に明確になります。


クラスメンバを使用する ~

"static member" を使用するのがクラスメンバの宣言としてとても普遍的で、新しいと
ころはありません。|Vim9| script ではその名前で直接アクセスできます。スクリプト
ローカルな変数を使う変数ととても似ています。オブジェクトメンバは "this." を常
に前置してアクセスし、こちらもどのメンバの種類かが明確になります。

TypeScript はクラス内であっても、クラス名をクラスメンバに前置します。これには2
つ問題があります: クラス名は必要以上に長く、スペースを余分に取り、クラスのリ
ネーム時に置いてある全部を変更する必要があります。


オブジェクトとクラスメンバの宣言 ~

主要な選択肢として変数の宣言に "var" を使用するかどうかがあります。
TypeScript は使用しない: >
	class Point {
	  x: number;
	  y = 0;
	}

踏襲するVimのオブジェクトメンバについてこのように宣言する: >
	class Point
	  this.x: number
	  this.y = 0
	endclass

何人かのユーザーからは宣言で割り当てるにはより良いと指摘された。"var" を追加し
たなら: >
	class Point
	  var this.x: number
	  var this.y = 0
	endclass

クラスメンバ "static" キーワードを使って宣言にできなくてはいけません。
"var" を外す選択もできる: >
	class Point
	  var this.x: number
	  static count = 0
	endclass

あるいは、"static" の前に使用する: >
	class Point
	  var this.x: number
	  var static count = 0
	endclass

あるいは "static" の後: >
	class Point
	  var this.x: number
	  static var count = 0
	endclass

これは "static def Func()" という行とより一致します。

これらは "var" を使用するかどうかの選択肢が明確ではありません。2つの理由から外
すことにしました:
1. TypeScript, Java, その他の人気の言語では使用していない。
2. 混乱を減らす。


オブジェクトのコンストラクタ "ClassName.new()" を使用する ~

多くの言語では "new" 演算子を使用してオブジェクトを生成しますが、コンストラク
タはコマンドではなく引数を持つメソッドとして定義されているので、実際には少し奇
妙です。TypeScript もまた "new" キーワードを持ちますが、しかしメソッドは
"constructor()" と呼ばれ、この2つの間の関係を見てとるのは困難です。

|Vim9| script ではコンストラクタメソッドは new() と呼ばれ、実行するのも new()
で、シンプルで直截的です。他の言語では "new ClassName()" を使用しますが
ClassName() メソッドはなく、ClassName クラス内の別の名前のメソッドです。かなり
混乱します。


オブジェクトのメンバのデフォルト読み出しアクセス ~

何人かのユーザーはオブジェクトメンバへアクセスするルールが非対称であることを覚
えなくてはいけません。これは意図的なものです。値の変更は値の読み出しとはとても
違う操作です。読み出し操作には副作用はなく、何回おこなってもオブジェクトに影響
を与えません。値の変更は多くの副作用があり、おなじくらい他のオブジェクトへの波
及効果もあります。

オブジェクトメンバを追加する時に通常はこのことは考えず、ただ型が正しいようにす
るだけです。そして通常 new() メソッドで値が設定されます。そうして多くの場合で
デフォルトとした読み出しアクセスのみでちょうどよく動きます。そして直に設定しよ
うとしたらエラーになり、許可されたい場合に驚くことになるでしょう。これはコード
を書くに間違いを減らすのを助けてくれます。


オブジェクトのメンバをアンダースコアでプライベートにする ~

オブジェクトメンバがプライベートの時、クラス(およびサブクラス)内からしか読み/
変更はできなくなり、クラスの外部からは使用できません。アンダースコアを前に付け
ることでシンプルに可視化できます。いくつかのプログラミング言語ではこれが推奨さ
れています。

考えを変えてオブジェクトメンバをクラス外からアクセス可能に変更したいときには、
すべての箇所のアンダースコアを削除する必要があります。名前はクラス(およびサブ
クラス)にのみ表れるので、見付けるのも変更するのも容易です。

逆の方法ははるかに大変です: クラス内のオブジェクトメンバの先頭にアンダースコア
を追加することでプライベートにできますが、しかしそれ以外の箇所の利用については
追跡して変更する必要があります。"set" メソッドの呼び出しにする必要がある場合も
あります。これは、アクセスを奪うには、そのアクセスが存在するすべての場所に対し
て作業を行う必要があるという現実の問題を反映しています。

別の方法として "private" キーワードを使用するというのがあり、これは "public"
とは違う方向にアクセスを変化させます。そうキーワード数を減らすためです。


オブジェクトのメンバに protected はない ~

いくつかの言語ではオブジェクトメンバのアクセス制御の手段をいくつか提供していま
す。最も知られているのは "protected" で、その意味は言語によって異ります。他に
は、"shared", "private", "friend" などがあります。

これらのルールは生活をより困難にします。多くの人々が間違いを犯しやすい同じ複雑
なコードに取り組むプロジェクトでは、これは当然のことです。とりわけ、リファクタ
リングや他のクラスモデルへの変更時などはそうです。

Vim script はプラグインへの使用が期待されていて、それは1人あるいは少人数チーム
で作業します。複雑なルールはより困難にするだけです。ルールにさらなる安全性を提
供する必要は本当にありません。単純さを保ち、特別なアクセスの詳細はなくていいの
です。


==============================================================================

10. 後で書く

newSomething() コンストラクタは他のコンストラクタを実行できる? そうである場合
は制限されるのは何か?

思い付いているもの:
- クラスのジェネリクス: `class <Tkey, Tentry>`
- 関数のジェネリクス: `def <Tkey> GetLast(key: Tkey)`
- ミックスイン: 役立つかどうかはわかりません。簡単にするために省略します。

いろいろ良さそうに見えるので追加する:
- テスト向け: モック機構

重要なクラスとして "Promise" の提供。Vimはシングルスレッドで、非同期動作との接
続はプラグインがユーザーをブロックしないで動作するには自然な手段です。これは
コールバックを呼び出しタイムアウトとエラーを扱う統一的手段です。


 vim:tw=78:ts=8:noet:ft=help:norl:
